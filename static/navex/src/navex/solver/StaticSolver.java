/**
 * @author Abeer Alhuzali
 * This class reads/extracts information from the set of TAC formulas generated by the Enhanced CPG traversals (in the paper algorithm 1)
 * For more information, please read "NAVEX: Precise and Scalable Exploit Generation for Dynamic Web Applications"
 *
 */
package navex.solver;

import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

import org.apache.commons.lang.ArrayUtils;
import org.apache.http.NameValuePair;
import org.apache.http.client.ClientProtocolException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import navex.Main;
import edu.uci.ics.crawler4j.util.IO;
import navex.formula.StaticFormulaInfo;


public class StaticSolver {

	private static final Logger logger = LoggerFactory.getLogger(Main.class);


	public static void main(String[] args) {

		/*
		 * creating spec files
		 * 
		 *
		 */




		
		// System.out.println("\nPlease enter the static analysis results file name (and full path) : ");
		
		File f = new File("test/");
		String[] pathNames = f.list();
		for (String pathName: pathNames) {
			if (pathName.startsWith("formula")) {
				try {
				 

				String results_File =  "test/" + pathName;
				
				//Scanner scanner = new Scanner(System.in);
				//System.out.println("\nPlease enter the attack type (sql, xss, code, os-command, file-inc, or ear): ");
				String attackType = "xss"; // scanner.next().trim();
				
				long startTime = System.currentTimeMillis();
		
				HashSet<StaticFormulaInfo> st = new HashSet<StaticFormulaInfo>();
		
				logger.debug(" ....Starting to generate Spec files for the list of static analysis formulas ....");
		
				switch (attackType){
				case "sql":
				case "xss": 
				case "code": //code execution
				case "os-command": //command injection
				case "file-inc": //file inclusion
					st = IO.readStaticAnalysisResultFile(results_File, attackType);
					break;
				case "ear": 
					st = IO.readStaticAnalysisResultFileEar(results_File, attackType);
					break;
				}
				mainHelper(st, attackType);
		
		
				long analysisEndTime = System.currentTimeMillis();
				long analysisDiffTime = (analysisEndTime - startTime);
		
				System.out.println("=====TOTAL: resolving inclusion + generating Spec Files + solving them====="+analysisDiffTime);
				}
				catch(Exception e){
				}
			}
		}
	}

	public static void mainHelper(HashSet<StaticFormulaInfo> st, String attackType){
		System.out.println("DEBUG: CHECK"); 
		HashMap<String, ArrayList<String>> incMap = IO.processIncludeMap(); 
		HashSet<String> hs = new HashSet<String>();

		for (StaticFormulaInfo s : st){
			//System.out.println("\n "+ s.toString());

			String part1 = s.getFile().replace("]", "");

			String cFile = "staticAnalysisSpec"+part1+"__"+s.getLineno()+"__"+s.getNode_id()+"__"+s.getSinkType()+"__"+s.getUnique_id();
			String get = null;  ArrayList<String> candidateUrls= null;
			SolverModel model= null;
			List<NameValuePair> varval =null;

			if (!attackType.contains("ear"))
			{
				model = getSolver(s);


				//processModel(model , incMap, get, candidateUrls, varval);
			}
			else 
				candidateUrls = resolveIncludeMapAndSolverModel(model, incMap, part1);


			/*
			 * Now we have to store this information in a file to feed it to 
			 * the traversal after performing the dynamic analysis.
			 */
			/*
			System.out.println("DEBUG: CHECK" + cFile); 
			String str = CreateIncludeMapResolutionFile(model, get,  candidateUrls, varval, incMap, cFile);


			boolean added= hs.add(str);
			//Edit the paths as needed .. 
			if (added && attackType.contains("sql"))
				IO.writeToFile("results/include_map_resolution_results.txt", str, true);
			else if (added && attackType.contains("xss")){
				IO.writeToFile("results/include_map_resolution_results_xss.txt", str, true);
			}
			else if (added && attackType.contains("code")){
				IO.writeToFile("results/include_map_resolution_results_code.txt", str, true);
			}
			else if (added && attackType.contains("os-command")){
				IO.writeToFile("results/include_map_resolution_results_os-command.txt", str, true);
			}
			else if (added && attackType.contains("file-inc")){
				IO.writeToFile("results/include_map_resolution_results_file-inc.txt", str, true);
			}
			else if (added && attackType.contains("ear")){
				IO.writeToFile("results/include_map_resolution_results_ear.txt", str, true);
			}
			*/
			System.out.println(">>>>>>>>>>>>>>>>DONE >>>>>>>>>>>>>>>>>");

		} 

	}
  //Edit paths to files as need
	private static String CreateIncludeMapResolutionFile(SolverModel model, String get, ArrayList<String> candidateUrls,
			List<NameValuePair> varval, HashMap<String, ArrayList<String>> incMap, String cFile) {

		
		String str= ""; 
		if (model != null){
			if ( get != null || model.getGetMap().size() > 0  || model.getNvps().size() > 0){
				System.out.print(cFile);
				
				for (String src :findSrcUrl(cFile))
				{
					System.out.println("source  url is "+src);
					if (incMap != null  ){
						str="FILE:"+cFile+"\n";
						str+= "SRC_URL:"+src+"\n"; 
					}
					str+="DEST_URL: ";
					if (candidateUrls != null && candidateUrls.size() > 0 ){

						for (String u : candidateUrls)
						{ str+=u+" ";
						System.out.println("u   "+u);

						}


					}
					else if ( (candidateUrls == null || candidateUrls.size() == 0) && model.getUrl() != null) {
						System.out.println("model.getUrl "+model.getUrl());
						str+= model.getUrl();
					}

					if (varval != null){
						str+="\nNameValuePair: ";
						for (NameValuePair p :varval){
							str+=p.toString()+" ";
						}
					}
					str+="\nget: ";
					if (get != null)
						str+=get;

				}
			}
		}	
		
		//in case of ear vulnerabilities
		else {
			for (String src :findSrcUrl(cFile))
			{   String localhost= "http://localhost/";
				
			    System.out.println("source  url is "+src);
				if (incMap != null  ){
					str="FILE:"+cFile+"\n";
					str+= "SRC_URL:"+src+"\n"; 
				    int index = src.indexOf("http://192.168.0.123");
					if (index != -1)
					    localhost = src.substring(0,index+("http://192.168.0.123/".length()) ); 
				}
				str+="DEST_URL: ";
				if (candidateUrls != null && candidateUrls.size() > 0 ){

					for (String u : candidateUrls)
					{ str+=u+" ";
					System.out.println("u   "+u);

					}
                  }
				else if ( (candidateUrls == null || candidateUrls.size() == 0) ) {
				   {
					   String url = cFile.replace("staticAnalysisSpec/var/www/html/", 
							   			localhost);
					   url= url.substring(0, url.indexOf("__"));
					   str+=url;
				   }
				   
				   }
	

			   str+="\nNameValuePair: ";
			
				str+="\nget: ";
				
			}
		}
		return str;		
	}
	/*
	 * once we have a model + include map, 
	 * we filter all SAT models and resolve the url from the 
	 * include map 
	 * output: list of destination urls with their NameValuePairs
	 */

	private static void processModel(SolverModel model, HashMap<String, ArrayList<String>> incMap
			,String get , ArrayList<String> candidateUrls,List<NameValuePair> varval ) {
		if (model.getSolution() != null && model.getUrl() != null && model.getSolution().startsWith("SAT")){
			int index = model.getUrl().indexOf("?");
			if (index != -1 )
				get = model.getUrl().substring(index+1);

			candidateUrls = resolveIncludeMapAndSolverModel(model, incMap, "");
			varval = model.getNvps(); 

		}


	}

	private static SolverModel getSolver(StaticFormulaInfo s) {
		
		Solver solve = new Solver(s.getFormula(), s.getSinkType());
		String spec = solve.prepareSolver();
		String part1 = s.getFile().replace("]", "");//.replace("/", "+").
		String cFile = "staticAnalysisSpec"+part1+"__"+s.getLineno()+"__"+s.getNode_id()+"__"+s.getSinkType()+"__"+s.getUnique_id();
		IO.writeToFile(cFile, spec, false);
		System.out.println(cFile);
		//System.out.println("====\n"+spec); 
		/*
		 * sending spec files to Z3 solver
		 */

		// Main.invokeSolver(cFile);

		System.out.println("---------------------------Done---");


		/*
		 * read the generated model and create an HTTP request 
		 */
		
		// SolverModel model = translateZ3model(cFile, s.getFile());

		//return model;
		return null;

	}

	
  /*
   * This is very specific to the tested apps in navex
   * please edit before testing
   */
	private static ArrayList<String> findSrcUrl(String url) {
		ArrayList<String> strl = null;
		String str=null;
		if (url.contains("/WeBid-v0.5.4")){
			strl= new ArrayList<String>();
			str="http://localhost/WeBid-v0.5.4/admin/login.php";
			strl.add(str);
			strl.add("http://localhost/WeBid-v0.5.4/index.php");
		}
		else if(url.toLowerCase().contains("zen-cart-1.5.5e")){
			strl= new ArrayList<String>();

			strl.add("http://localhost/zen-cart-1.5.5e/index.php");
		}

		else if(url.toLowerCase().contains("/collabtive-12/")){
			strl= new ArrayList<String>();

			strl.add("http://localhost/collabtive-12/index.php");
		}

		else if(url.contains("/phpBB2/")){
			strl= new ArrayList<String>();

			strl.add("http://localhost/phpBB2/index.php");
			strl.add("http://localhost/phpBB2/admin/index.php");
		}

		else if(url.toLowerCase().contains("/oscommerce-2.3.3/")){
			strl= new ArrayList<String>();

			strl.add("http://localhost/oscommerce-2.3.3/catalog/index.php");
			strl.add("http://localhost/oscommerce-2.3.3/catalog/admin/index.php");
		}

		else if(url.toLowerCase().contains("/hotcrp-2.60/")){
			strl= new ArrayList<String>();

			strl.add("http://localhost/hotcrp-2.60/index.php");
		}
		else if(url.toLowerCase().contains("/mybloggie/")){
			strl= new ArrayList<String>();

			strl.add("http://localhost/mybloggie/index.php");
		}

		return strl;
	}

	private static ArrayList<String> resolveIncludeMapAndSolverModel(SolverModel model,
			HashMap<String, ArrayList<String>> incMap, String fileName) {

		ArrayList<String> cadidateUrls =null;
   if (model != null){
		if (model.getSolution() != null && model.getSolution().startsWith("SAT"))
		{
			String urlOnly = null;
			if (model.getUrl().indexOf(".php") != -1)
				urlOnly= model.getUrl().substring(model.getUrl().lastIndexOf("/")+1, model.getUrl().indexOf(".php")+4);
			else if (model.getUrl().indexOf(".inc") != -1)
				urlOnly= model.getUrl().substring(model.getUrl().lastIndexOf("/")+1, model.getUrl().indexOf(".inc")+4);

			int start = model.getUrl().indexOf("localhost/")+10;
			String appName= model.getUrl().substring(start, model.getUrl().indexOf("/", start));
			String fromAppNameToEnd = null;
			if (model.getUrl().indexOf(".php") != -1)
				fromAppNameToEnd =model.getUrl().substring(model.getUrl().indexOf(appName) , model.getUrl().indexOf(".php")+4) ;
			else if (model.getUrl().indexOf(".inc") != -1)
				fromAppNameToEnd =model.getUrl().substring(model.getUrl().indexOf(appName) , model.getUrl().indexOf(".inc")+4) ;

			System.out.println(" model.getUrl() "+ model.getUrl()+"   urlOnly "+urlOnly+
					"  appName: "+appName+"  fromAppNameToEnd :"+fromAppNameToEnd);
			if (!incMap.containsKey(fromAppNameToEnd) ){ 

				cadidateUrls = new ArrayList<String>();
				for (Map.Entry<String, ArrayList<String>> map: incMap.entrySet()){
					if (map.getKey().contains(appName)){
						for (String val : map.getValue()){
							if ((val).contains(urlOnly) ){ 
								System.out.println("val "+val);
								cadidateUrls.add(map.getKey());
							}
						}
					}
				}
			}
		}
   }
   //model == null in case of ear vulnerabilities
   //"/var/www/html/" is the location of the deployed apps evaluated in navex. Edit as needed
		else {
			String urlOnly = null;
			//if there was post vars
			if (fileName.indexOf(".php") != -1)
				urlOnly= fileName.substring(fileName.lastIndexOf("/")+1, fileName.indexOf(".php")+4);
			else if (fileName.indexOf(".inc") != -1)
				urlOnly= fileName.substring(fileName.lastIndexOf("/")+1, fileName.indexOf(".inc")+4);

			int start = fileName.indexOf("/var/www/html/")+("/var/www/html/".length());
			String appName= fileName.substring(start, fileName.indexOf("/", start));
			String fromAppNameToEnd = null;
			if (fileName.indexOf(".php") != -1)
				fromAppNameToEnd =fileName.substring(fileName.indexOf(appName) , fileName.indexOf(".php")+4) ;
			else if (fileName.indexOf(".inc") != -1)
				fromAppNameToEnd =fileName.substring(fileName.indexOf(appName) , fileName.indexOf(".inc")+4) ;

			System.out.println(" fileName "+ fileName+"   urlOnly "+urlOnly+
					"  appName: "+appName+"  fromAppNameToEnd :"+fromAppNameToEnd);
			if (!incMap.containsKey(fromAppNameToEnd) ){ 

				cadidateUrls = new ArrayList<String>();
				for (Map.Entry<String, ArrayList<String>> map: incMap.entrySet()){
					if (map.getKey().contains(appName)){
						for (String val : map.getValue()){
							//System.out.println("val "+val);
							if ((val).contains(urlOnly) ){  //val).equals(urlOnly)
								System.out.println("val "+val);
								cadidateUrls.add(map.getKey());
							}
						}
					}
				}
			}
		}
		return cadidateUrls;

	}

/*
 * "/var/www/html/" is the location of the deployed apps evaluated in navex. Edit as needed
 *  Localhost is our test server. Edit as needed
 */

	private static SolverModel translateZ3model(String cFile, String url) {

		url = url.replace("/var/www/html", "http://localhost").trim();
		String[] mArgs = {cFile+".model", "" ,  url, "static"};
		List <NameValuePair> params = null;
		SolverModel model = new SolverModel();
		try {
			params = model.main(mArgs, null);
		} catch (ClientProtocolException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (URISyntaxException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}catch(IllegalThreadStateException e){
			e.printStackTrace();
		}
		
		System.out.println("the model url is "+model.getUrl());
		System.out.println("the model <val,value> is "+model.getNvps().toString());

		return model;

	}




}
